<!doctype html>
<html>
	<head>
		<title>
			Games
		</title>
		<base target="_blank">
		<script src="https://epicenterprograms.github.io/standards/behavior/general.js"></script>
		<script src="https://epicenterprograms.github.io/standards/behavior/storage.js"></script>
		<script src="https://epicenterprograms.github.io/standards/behavior/game.js"></script>
		<!--
		<script src="file:///C:/Users/rtben/Documents/GitHub/standards/behavior/game.js"></script>
		-->
		<script src="behavior.js"></script>
		<script>
			var size = {  // the size of the game board
				x: 3,
				y: 3,
				z: 3
			};
			var currentLayer = 0;  // the current layer chosen, a.k.a. the type of piece chosen
			var standbys = [[], [], [], []];  // the unused game pieces for each player
			var options = [];  // the potential places to put a game piece (contains the entity references)
			var currentPiece = null;  // the currently selected game piece
			var currentPlayer = 0;
			var players = 1;  // the number of real players
			var colors = ["red", "green", "blue", "purple"];  // the color of the player pieces clockwise from bottom
			var piecesPerLayer = 3;  // the number of pieces allowed per layer

			function choiceAvailable(option) {
				/**
				checks whether the chosen option is available
				*/
				return option.dataset["z" + currentLayer + "IsOpen"] === "true" ? true : false;
			}

			function makeAMove(option) {
				/**
				moves one of a player's pieces to a space on the game board
				*/
				S.forEach(["top", "bottom", "left", "right"], function (side) {
					currentPiece.style[side] = "auto";  // prevents irregularities from a value on a different side conflicting
				});
				currentPiece.style.left = "calc(" + option.style.left + " + var(--game-space-width) / 2 - " + currentPiece.style.width + " / 2)";
				currentPiece.style.top = "calc(" + option.style.top + " + var(--game-space-width) / 2 - " + currentPiece.style.width + " / 2)";
				currentPiece.style.pointerEvents = "none";
				option.dataset["z" + currentLayer + "IsOpen"] = false;
				currentPiece = null;
				if (gameHasEnded()) {
					//// end the game
				}
			}

			var Opponent = function (playerNumber, startingPoint) {
				/**
				Provides an adaptive opponent with an optional previous level of knowledge
				*/
				var opponent = this;

				this.takeATurn = function () {
					var position = {  // the position where the opponent is planning on placing a piece
						x: 0,
						y: 0,
						z: 0,
					};
					var desiredOption;
					currentPlayer = playerNumber;
					do {
						position.x = Math.floor(Math.random() * size.x);
						position.y = Math.floor(Math.random() * size.y);
						do {
							position.z = Math.floor(Math.random() * size.z);
						} while (standbys[currentPlayer][position.z].length > 0);
						desiredOption = options[position.x][position.y];
						currentLayer = position.z;
					} while (!choiceAvailable(desiredOption));
					currentPiece = standbys[currentPlayer][currentLayer][0];
					makeAMove(desiredOption);
				}
			};

			function gameHasEnded() {
				// checks if anyone has won

				// checks if there's a stalemate
				let stalemate = true;
				S.forEach(options, function (xList) {
					S.forEach(xList, function (option) {
						S.forEach(size.z, function (_, index) {
							currentLayer = index;
							if (choiceAvailable(option)) {
								stalemate = false;
							}
						});
					});
				});
				if (stalemate) {
					S.makeDialog("No more spaces are available.");
					return true;
				}
			}

			S.listen("play", "click", function () {
				// resets all of the variables
				size = {  // the size of the game board
					x: 3,
					y: 3,
					z: 3
				};
				currentLayer = 0;  // the current layer chosen, a.k.a. the type of piece chosen
				standbys = [[], [], [], []];  // the unused game pieces for each player
				options = [];  // the potential places to put a game piece (contains the entity references)
				currentPiece = null;  // the currently selected game piece
				currentPlayer = 0;
				players = 1;  // the number of real players
				colors = ["red", "green", "blue", "purple"];  // the color of the player pieces clockwise from bottom
				piecesPerLayer = 3;  // the number of pieces allowed per layer

				// creates the game board
				S.getId("gameScreen").innerHTML = "";
				S.forEach(size.x, function (_, xIndex) {
					options.push([]);
					S.forEach(size.y, function (_, yIndex) {
						let square = document.createElement("div");
						square.className = "playing-space generic-border";
						square.style.left = "calc(var(--game-screen-width) / 2 + " + (xIndex - size.x / 2) + " * var(--game-space-width))";
						square.style.top = "calc(var(--game-screen-width) / 2 + " + (yIndex - size.y / 2) + " * var(--game-space-width))";
						/// middle of gameScreen + how many game spaces to move to either side
						S.forEach(size.z, function (_, zIndex) {
							square.dataset["z" + zIndex + "IsOpen"] = true;
						});
						options[xIndex].push(square);
						S.getId("gameScreen").appendChild(square);
						square.addEventListener("click", function () {
							if (currentPiece !== null && choiceAvailable(this)) {
								makeAMove(this);
							}
						});
					});
				});

				// gives the players their pieces
				S.forEach(4, function (_, playerIndex) {
					S.forEach(size.z, function (_, layerIndex) {
						standbys[playerIndex].push([]);
						S.forEach(piecesPerLayer, function (pieceIndex) {
							let piece = document.createElement("div");
							piece.className = "game-piece";
							piece.style.borderColor = colors[playerIndex];
							let pieceSize = "calc(" + (layerIndex + 1) + " * var(--game-space-width) / " + size.z + ")";
							piece.style.width = pieceSize;
							piece.style.height = pieceSize;
							piece.style[["left", "top", "right", "bottom"][playerIndex]] = "calc(var(--game-screen-width) / 2 + " + (layerIndex - size.x / 2) + " * var(--game-space-width) + var(--game-space-width) / 2 - " + pieceSize + " / 2)";
							/// middle of gameScreen + how many game spaces to move to either side + half a game space - half a piece width
							piece.style[["bottom", "left", "top", "right"][playerIndex]] = "calc(var(--game-screen-width) / 35)";
							standbys[playerIndex][layerIndex].push(piece);
							S.getId("gameScreen").appendChild(piece);
							piece.addEventListener("click", function () {
								currentPiece = this;
								currentLayer = layerIndex;
								currentPlayer = playerIndex;
							});
						});
					});
				});
			});
		</script>
		<link rel="stylesheet" href="https://epicenterprograms.github.io/standards/formatting/foundation.css">
		<link rel="stylesheet" href="https://epicenterprograms.github.io/standards/formatting/game.css">
		<style>
			#gameScreen {
				--game-screen-width: 35rem;
				--game-space-width: calc(var(--game-screen-width) / 6);
				position: relative;
				width: var(--game-screen-width);
				height: var(--game-screen-width);
			}
			.playing-space {
				position: absolute;
				z-index: 0;
				border-width: calc(var(--game-screen-width) / 80);
				width: var(--game-space-width);
				height: var(--game-space-width);
				cursor: pointer;
			}
			.game-piece {
				position: absolute;
				z-index: 1;
				border-width: calc(var(--game-screen-width) / 35);
				border-style: solid;
				border-radius: 100em;  /* just an abritrary number higher than will be ever used */
				opacity: .5;
				cursor: pointer;
				transition: 1s;
			}

			@media (max-width: 1000px) {
				main {
					padding: 0%;
				}
				#gameScreen {
					--game-screen-width: 100vw;
				}
			}
		</style>
	</head>
	<body>
		<nav class="hidden-left-nav">
			<iframe src="navigation.html"></iframe>
		</nav>
		<h1 class="main-title">
			Otrio
		</h1>
		<main>
			<section>
				3-dimensional Tic-Tac-Toe
			</section>
			<button id="play">
				Play
			</button>
			<br>
			<div class="generic-background" id="gameScreen"></div>
		</main>
	</body>
</html>
